package com.francesc.treasuremap.oo;

/**
 * 
 * @author Francesc Qui–ones Gispert
 * @date 12/09/2012
 * 
 *       This class implements the Treasure's Map solver in interative approach.
 * 
 */
public class TreasureMapIterative extends Map {

	/**
	 * Contructor for autogenerated maps
	 * 
	 * @param x
	 *            width
	 * @param y
	 *            height
	 * @param threshold
	 *            threshold
	 */
	public TreasureMapIterative(int x, int y, double threshold) {
		super(x, y, threshold);
	}

	/**
	 * Treasure map from outer param
	 * 
	 * @param map
	 *            int [][] treasure map
	 */
	public TreasureMapIterative(int[][] map) {
		super(map);
	}

	/**
	 * Redirects to solvePointIterative
	 */
	@Override
	public void solvePoint(int x, int y) {
		solvePointIterative(x, y);
	}

	/**
	 * Solves the problem using the iterative approach. This approach is quicker
	 * than recursive
	 * 
	 * @param x
	 *            width position to evaluate
	 * @param y
	 *            height position to evaluate
	 */
	private void solvePointIterative(int x, int y) {
		int count = 0;
		Point p = null;

		// go through nearby points
		for (int i = x - 1; i < x + 2; i++) {

			for (int j = y - 1; j < y + 2; j++) {
				if (isInGrid(i, j)) {
					//
					p = (Point) getMap().get(i).get(j);
					// evaluate the point
					if (p.isTreasurePoint()) {
						count++;
					}
				}
			}
		}

		p = (Point) getMap().get(x).get(y);
		// save the num of threasures to evaluated point
		p.setNumTreasures(count);
	}

}
